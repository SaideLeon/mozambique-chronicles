ARQUIVOS PYTHON
================================================================================
Diretório base: ./backend
========================================

================================================================================
Arquivo: ./backend/backend/__init__.py
================================================================================



================================================================================
Arquivo: ./backend/backend/asgi.py
================================================================================

"""
ASGI config for backend project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')

application = get_asgi_application()


================================================================================
Arquivo: ./backend/backend/settings.py
================================================================================

# settings.py

import os
from pathlib import Path
from decouple import config
from datetime import timedelta

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent
ROOT_URLCONF = 'backend.urls'

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = config('DJANGO_SECRET_KEY', default='maybe_5432!')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

# Allowed Hosts
ALLOWED_HOSTS = [
    '.choreoapps.dev',
    'localhost',
    '127.0.0.1',
]

# Application definition
INSTALLED_APPS = [
    "jazzmin",
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Third party apps
    
    'rest_framework',
    'rest_framework.authtoken', 
    'corsheaders',
    
    # Local apps
    'chronicles',
    'visitors',
    'social',
]

# Authentication
AUTH_USER_MODEL = 'visitors.Visitor'

AUTHENTICATION_BACKENDS = [
    'visitors.backends.EmailBackend',
    'django.contrib.auth.backends.ModelBackend',
]

# Update REST_FRAMEWORK settings
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.TokenAuthentication',
        'rest_framework.authentication.SessionAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticatedOrReadOnly',
    ],
    'DEFAULT_PARSER_CLASSES': [
        'rest_framework.parsers.JSONParser',
        'rest_framework.parsers.FormParser',
        'rest_framework.parsers.MultiPartParser',
    ],
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework.renderers.JSONRenderer',
        'rest_framework.renderers.BrowsableAPIRenderer',
    ],
    'DEFAULT_THROTTLE_CLASSES': [
        'rest_framework.throttling.AnonRateThrottle',
        'rest_framework.throttling.UserRateThrottle'
    ],
    'DEFAULT_THROTTLE_RATES': {
        'anon': '100/hour',
        'user': '1000/hour'
    }
}

# Jazzmin Settings
JAZZMIN_SETTINGS = {
    "site_title": "Crônicas Admin",
    "site_header": "Painel de Administração",
    "site_brand": "Crônicas de Moz",
    "welcome_sign": "Bem-vindo ao Painel de Administração",
    "search_model": "auth.User",
    "topmenu_links": [
        {"name": "Home", "url": "admin:index", "permissions": ["auth.view_user"]},
        {"name": "Documentação", "url": "https://docs.djangoproject.com", "new_window": True},
    ],
    "usermenu_links": [
        {"model": "auth.user"},
    ],
    "icons": {
        "auth": "fas fa-users-cog",
        "auth.user": "fas fa-user",
        "auth.Group": "fas fa-users",
    },
    "default_icon_parents": "fas fa-chevron-circle-right",
    "default_icon_children": "fas fa-circle",
    "related_modal_active": True,
    "custom_css": None,
    "custom_js": None,
    "show_ui_builder": True,
    "ui_tweaks": {
        "navbar_small_text": False,
        "footer_small_text": False,
        "body_small_text": False,
        "brand_small_text": False,
        "brand_colour": False,
        "accent": "accent-primary",
        "navbar": "navbar-dark",
        "no_navbar_border": True,
        "navbar_fixed": True,
        "layout_boxed": False,
        "footer_fixed": False,
        "sidebar_fixed": True,
        "sidebar": "sidebar-dark-primary",
        "sidebar_nav_small_text": False,
        "sidebar_disable_expand": False,
        "sidebar_nav_child_indent": True,
        "sidebar_nav_compact_style": False,
        "sidebar_nav_legacy_style": False,
        "sidebar_nav_flat_style": False,
        "theme": "darkly",
        "dark_mode_theme": "darkly",
        "button_classes": {
            "primary": "btn-primary",
            "secondary": "btn-secondary",
            "info": "btn-info",
            "warning": "btn-warning",
            "danger": "btn-danger",
            "success": "btn-success"
        }
    }
}

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

# CORS settings
CORS_ALLOWED_ORIGINS = [
    'https://cronicasmz.choreoapps.dev',
    "http://localhost:5173",
]

CORS_ALLOW_METHODS = [
    'GET',
    'POST',
    'PUT',
    'PATCH',
    'DELETE',
    'OPTIONS',
]

# Database Configuration
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

# Logging Configuration
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
        'file': {
            'class': 'logging.FileHandler',
            'filename': os.path.join(BASE_DIR, 'django.log'),
            'formatter': 'verbose',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': False,
        },
        'visitors': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': True,
        },
    },
    'root': {
        'handlers': ['console', 'file'],
        'level': 'INFO',
    },
}

# Templates Configuration
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

# Static files configuration
STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'

# Media files
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

# Security Settings (comentados para desenvolvimento)
"""
SECURE_SSL_REDIRECT = True
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True
X_FRAME_OPTIONS = 'DENY'
SECURE_HSTS_SECONDS = 31536000  # 1 year
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True
"""

# Internationalization
LANGUAGE_CODE = 'pt-br'
TIME_ZONE = 'Africa/Maputo'
USE_I18N = True
USE_L10N = True
USE_TZ = True

# Default primary key field type
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Session Settings
SESSION_ENGINE = 'django.contrib.sessions.backends.db'
SESSION_COOKIE_AGE = 1209600  # 2 weeks in seconds

================================================================================
Arquivo: ./backend/backend/urls.py
================================================================================

from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static
from rest_framework.routers import DefaultRouter
from chronicles.views import ChronicleViewSet, FeaturedChronicleViewSet

# Configuração do router principal
router = DefaultRouter()
router.register(r'chronicles', ChronicleViewSet)
router.register(r'featured-chronicles', FeaturedChronicleViewSet)

# Customização do admin
admin.site.site_header = 'Administração do Site'
admin.site.site_title = 'Portal Admin'
admin.site.index_title = 'Bem-vindo ao Portal Administrativo'

urlpatterns = [
    # Admin URLs
    path('admin/', admin.site.urls),
    
    # API URLs
    path('api/', include(router.urls)),
    path('api/', include("visitors.urls")),
        path('api/', include("social.urls")),

    
    # DRF auth URLs (opcional - para interface de navegação da API)
    path('api-auth/', include('rest_framework.urls')),
    
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

# Configuração para servir arquivos de mídia em desenvolvimento
if settings.DEBUG:
    # Adiciona URLs para servir arquivos estáticos em desenvolvimento
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
    
    # Opcional: Adiciona URLs do debug_toolbar se estiver instalado
    try:
        import debug_toolbar
        urlpatterns = [
            path('__debug__/', include(debug_toolbar.urls)),
        ] + urlpatterns
    except ImportError:
        pass



================================================================================
Arquivo: ./backend/backend/wsgi.py
================================================================================

"""
WSGI config for backend project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')

application = get_wsgi_application()


================================================================================
Arquivo: ./backend/chronicles/__init__.py
================================================================================



================================================================================
Arquivo: ./backend/chronicles/admin.py
================================================================================

from django.contrib import admin
from django.utils.html import format_html
from .models import Chronicle, FeaturedChronicle

@admin.register(Chronicle)
class ChronicleAdmin(admin.ModelAdmin):
    list_display = ('title', 'author', 'date', 'created_at', 'pdf_link')
    search_fields = ('title', 'content', 'author__username', 'author__first_name', 'author__last_name')
    list_filter = ('date', 'created_at', 'author', 'updated_at')
    date_hierarchy = 'date'
    readonly_fields = ('created_at', 'updated_at')
    fieldsets = (
        ('Informações Principais', {
            'fields': ('title', 'date', 'author')
        }),
        ('Conteúdo', {
            'fields': ('content', 'pdf_file')
        }),
        ('Informações do Sistema', {
            'fields': ('created_at', 'updated_at'),
            'classes': ('collapse',)
        }),
    )

    def pdf_link(self, obj):
        if obj.pdf_file:
            return format_html('<a href="{}" target="_blank">Abrir PDF</a>', obj.pdf_file.url)
        return "Sem PDF"
    pdf_link.short_description = 'PDF'

    def save_model(self, request, obj, form, change):
        if not obj.author_id:
            obj.author = request.user
        super().save_model(request, obj, form, change)

    def has_add_permission(self, request):
        return request.user.is_superuser

    def has_change_permission(self, request, obj=None):
        return request.user.is_superuser

    def has_delete_permission(self, request, obj=None):
        return request.user.is_superuser

@admin.register(FeaturedChronicle)
class FeaturedChronicleAdmin(admin.ModelAdmin):
    list_display = ('title', 'user', 'date', 'created_at', 'pdf_link')
    search_fields = ('title', 'content', 'user__username', 'user__first_name', 'user__last_name')
    list_filter = ('date', 'created_at', 'user', 'updated_at')
    date_hierarchy = 'date'
    readonly_fields = ('created_at', 'updated_at')
    fieldsets = (
        ('Informações Principais', {
            'fields': ('title', 'date', 'user'),
            'description': 'Cada superusuário pode ter apenas uma crônica principal ativa.'
        }),
        ('Conteúdo', {
            'fields': ('content', 'pdf_file'),
            'description': 'O arquivo PDF é obrigatório para crônicas principais.'
        }),
        ('Informações do Sistema', {
            'fields': ('created_at', 'updated_at'),
            'classes': ('collapse',)
        }),
    )

    def pdf_link(self, obj):
        if obj.pdf_file:
            return format_html('<a href="{}" target="_blank">Abrir PDF</a>', obj.pdf_file.url)
        return "Sem PDF"
    pdf_link.short_description = 'PDF'

    def save_model(self, request, obj, form, change):
        if not obj.user_id:
            obj.user = request.user
        super().save_model(request, obj, form, change)

    def has_add_permission(self, request):
        return request.user.is_superuser

    def has_change_permission(self, request, obj=None):
        return request.user.is_superuser

    def has_delete_permission(self, request, obj=None):
        return request.user.is_superuser

    def get_queryset(self, request):
        qs = super().get_queryset(request)
        if not request.user.is_superuser:
            return qs.none()
        return qs

    class Media:
        css = {
            'all': ('admin/css/featured_chronicle.css',)
        }
        js = ('admin/js/featured_chronicle.js',)

================================================================================
Arquivo: ./backend/chronicles/apps.py
================================================================================

from django.apps import AppConfig


class ChroniclesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'chronicles'


================================================================================
Arquivo: ./backend/chronicles/models.py
================================================================================

# chronicles/models.py
from django.db import models
from django.conf import settings
from django.db.models.signals import pre_save
from django.dispatch import receiver

class Chronicle(models.Model):
    date = models.DateField()
    title = models.CharField(max_length=200)
    content = models.TextField()
    pdf_file = models.FileField(upload_to='pdfs/', null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        null=True, blank=True,
        limit_choices_to={'is_superuser': True},
        help_text="Apenas superusuários podem criar crônicas"
    )

    class Meta:
        ordering = ['-date']
        verbose_name = "Crônica"
        verbose_name_plural = "Crônicas"

    def __str__(self):
        return self.title

class FeaturedChronicle(models.Model):
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        limit_choices_to={'is_superuser': True},
        help_text="Apenas superusuários podem criar crônicas principais"
    )
    date = models.DateField()
    title = models.CharField(max_length=200)
    content = models.TextField()
    pdf_file = models.FileField(
        upload_to='featured_pdfs/',
        help_text="Upload do arquivo PDF da crônica principal"
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "Crônica Principal"
        verbose_name_plural = "Crônicas Principais"
        ordering = ['-date']

    def __str__(self):
        return f"Crônica Principal - {self.title} ({self.user.email})"  # Changed to email since that's our username field

    def save(self, *args, **kwargs):
        if not self.pk:
            FeaturedChronicle.objects.filter(user=self.user).delete()
        super().save(*args, **kwargs)

# Signal para garantir que apenas superusuários possam criar crônicas
@receiver(pre_save, sender=Chronicle)
@receiver(pre_save, sender=FeaturedChronicle)
def ensure_superuser(sender, instance, **kwargs):
    user = instance.author if sender == Chronicle else instance.user
    if not user.is_superuser:
        raise ValueError("Apenas superusuários podem criar crônicas")

================================================================================
Arquivo: ./backend/chronicles/tests.py
================================================================================

from django.test import TestCase

# Create your tests here.


================================================================================
Arquivo: ./backend/chronicles/views.py
================================================================================

from rest_framework import viewsets, permissions
from rest_framework.parsers import MultiPartParser, FormParser
from django.core.exceptions import ValidationError
from django.utils.translation import gettext as _
from .models import Chronicle, FeaturedChronicle
from .serializers import ChronicleSerializer, FeaturedChronicleSerializer

class IsSuperUserOrReadOnly(permissions.BasePermission):
    """
    Permissão personalizada que permite apenas superusuários
    criar, editar ou excluir objetos.
    """
    def has_permission(self, request, view):
        # Permite visualização para todos
        if request.method in permissions.SAFE_METHODS:
            return True
        # Requer superusuário para outras operações
        return request.user and request.user.is_superuser

    def has_object_permission(self, request, view, obj):
        # Permite visualização para todos
        if request.method in permissions.SAFE_METHODS:
            return True
        # Requer superusuário para outras operações
        return request.user and request.user.is_superuser

class ChronicleViewSet(viewsets.ModelViewSet):
    queryset = Chronicle.objects.all()
    serializer_class = ChronicleSerializer
    permission_classes = [IsSuperUserOrReadOnly]
    parser_classes = (MultiPartParser, FormParser)
    
    def perform_create(self, serializer):
        """
        Salva o autor automaticamente como o usuário atual
        """
        if not self.request.user.is_superuser:
            raise ValidationError(_("Apenas superusuários podem criar crônicas."))
        serializer.save(author=self.request.user)
    
    def get_queryset(self):
        """
        Customiza a queryset com ordenação e possíveis filtros
        """
        queryset = Chronicle.objects.all().order_by('-date', '-created_at')
        
        # Exemplo de filtros opcionais por query params
        date = self.request.query_params.get('date', None)
        if date is not None:
            queryset = queryset.filter(date=date)
            
        author = self.request.query_params.get('author', None)
        if author is not None and self.request.user.is_superuser:
            queryset = queryset.filter(author__username=author)
            
        return queryset

class FeaturedChronicleViewSet(viewsets.ModelViewSet):
    queryset = FeaturedChronicle.objects.all()
    serializer_class = FeaturedChronicleSerializer
    permission_classes = [IsSuperUserOrReadOnly]
    parser_classes = (MultiPartParser, FormParser)
    
    def perform_create(self, serializer):
        """
        Salva o usuário automaticamente e garante que só exista
        uma crônica principal por usuário
        """
        if not self.request.user.is_superuser:
            raise ValidationError(_("Apenas superusuários podem criar crônicas principais."))
            
        # Remove crônica principal existente do usuário
        FeaturedChronicle.objects.filter(user=self.request.user).delete()
        serializer.save(user=self.request.user)
    
    def get_queryset(self):
        """
        Customiza a queryset com ordenação e possíveis filtros
        """
        queryset = FeaturedChronicle.objects.all().order_by('-date', '-created_at')
        
        # Exemplo de filtros opcionais por query params
        date = self.request.query_params.get('date', None)
        if date is not None:
            queryset = queryset.filter(date=date)
            
        user = self.request.query_params.get('user', None)
        if user is not None and self.request.user.is_superuser:
            queryset = queryset.filter(user__username=user)
            
        return queryset



================================================================================
Arquivo: ./backend/chronicles/serializers.py
================================================================================

from rest_framework import serializers
from .models import Chronicle, FeaturedChronicle
from django.utils.formats import date_format
from django.utils.translation import gettext as _
import locale

# Configurar locale para português
try:
    locale.setlocale(locale.LC_TIME, 'pt_BR.UTF-8')
except:
    try:
        locale.setlocale(locale.LC_TIME, 'Portuguese_Brazil.1252')
    except:
        pass

class ChronicleSerializer(serializers.ModelSerializer):
    date_formatted = serializers.SerializerMethodField()
    author_name = serializers.SerializerMethodField()
    pdf_url = serializers.SerializerMethodField()
    
    class Meta:
        model = Chronicle
        fields = [
            'id', 
            'date', 
            'date_formatted', 
            'title', 
            'content', 
            'pdf_file',
            'pdf_url',
            'author',
            'author_name',
            'created_at',
            'updated_at'
        ]
        read_only_fields = ['author', 'created_at', 'updated_at']
        
    def get_date_formatted(self, obj):
        """Retorna a data formatada em português"""
        try:
            return obj.date.strftime("%d de %B de %Y").lower()
        except:
            return date_format(obj.date, format="d \d\e F \d\e Y", use_l10n=True)

    def get_author_name(self, obj):
        """Retorna o nome do autor"""
        return obj.author.get_full_name() or obj.author.username
    
    def get_pdf_url(self, obj):
        """Retorna a URL completa do PDF se existir"""
        if obj.pdf_file:
            request = self.context.get('request')
            if request is not None:
                return request.build_absolute_uri(obj.pdf_file.url)
        return None

    def validate_author(self, value):
        """Valida se o autor é um superusuário"""
        if not value.is_superuser:
            raise serializers.ValidationError(
                _("Apenas superusuários podem criar ou editar crônicas.")
            )
        return value

class FeaturedChronicleSerializer(serializers.ModelSerializer):
    date_formatted = serializers.SerializerMethodField()
    user_name = serializers.SerializerMethodField()
    pdf_url = serializers.SerializerMethodField()
    
    class Meta:
        model = FeaturedChronicle
        fields = [
            'id', 
            'date', 
            'date_formatted', 
            'title', 
            'content', 
            'pdf_file',
            'pdf_url',
            'user',
            'user_name',
            'created_at',
            'updated_at'
        ]
        read_only_fields = ['user', 'created_at', 'updated_at']
        
    def get_date_formatted(self, obj):
        """Retorna a data formatada em português"""
        try:
            return obj.date.strftime("%d de %B de %Y").lower()
        except:
            return date_format(obj.date, format="d \d\e F \d\e Y", use_l10n=True)

    def get_user_name(self, obj):
        """Retorna o nome do usuário"""
        return obj.user.get_full_name() or obj.user.username
    
    def get_pdf_url(self, obj):
        """Retorna a URL completa do PDF"""
        request = self.context.get('request')
        if request is not None:
            return request.build_absolute_uri(obj.pdf_file.url)
        return None

    def validate_user(self, value):
        """Valida se o usuário é um superusuário"""
        if not value.is_superuser:
            raise serializers.ValidationError(
                _("Apenas superusuários podem criar ou editar crônicas principais.")
            )
        return value

    def create(self, validated_data):
        """
        Sobrescreve o método create para garantir que cada usuário
        tenha apenas uma crônica principal
        """
        user = self.context['request'].user
        # Remove qualquer crônica principal existente do usuário
        FeaturedChronicle.objects.filter(user=user).delete()
        # Cria a nova crônica principal
        return super().create(validated_data)

================================================================================
Arquivo: ./backend/visitors/__init__.py
================================================================================



================================================================================
Arquivo: ./backend/visitors/admin.py
================================================================================

# visitors/admin.py
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin
from .models import Visitor

@admin.register(Visitor)
class VisitorAdmin(UserAdmin):
    list_display = ('email', 'name', 'is_verified', 'created_at')
    list_filter = ('is_verified', 'created_at')
    search_fields = ('email', 'name')
    ordering = ('-created_at',)
    
    fieldsets = (
        (None, {'fields': ('email', 'password')}),
        ('Informações Pessoais', {'fields': ('name',)}),
        ('Permissões', {'fields': ('is_verified', 'is_active', 'is_staff', 'is_superuser')}),
    )
    
    add_fieldsets = (
        (None, {
            'classes': ('wide',),
            'fields': ('email', 'name', 'password1', 'password2'),
        }),
    )


================================================================================
Arquivo: ./backend/visitors/apps.py
================================================================================

from django.apps import AppConfig


class VisitorsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'visitors'


================================================================================
Arquivo: ./backend/visitors/models.py
================================================================================

# visitors/models.py
from django.db import models
from django.contrib.auth.models import AbstractUser, Group, Permission
from django.utils.translation import gettext_lazy as _

class Visitor(AbstractUser):
    email = models.EmailField(_('email address'), unique=True)
    name = models.CharField(max_length=255)
    is_verified = models.BooleanField(default=False)
    verification_token = models.CharField(max_length=100, blank=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    # Customizing related_name to avoid conflicts
    groups = models.ManyToManyField(
        Group,
        related_name='visitor_groups',  # Custom related_name
        blank=True,
    )
    user_permissions = models.ManyToManyField(
        Permission,
        related_name='visitor_permissions',  # Custom related_name
        blank=True,
    )

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['username', 'name']

    class Meta:
        verbose_name = 'Visitante'
        verbose_name_plural = 'Visitantes'
        
    

================================================================================
Arquivo: ./backend/visitors/tests.py
================================================================================

from django.test import TestCase

# Create your tests here.


================================================================================
Arquivo: ./backend/visitors/views.py
================================================================================

# visitors/views.py
from rest_framework import status
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import AllowAny
from .serializers import VisitorRegistrationSerializer, LoginSerializer
from .models import Visitor
from django.contrib.auth import authenticate
from rest_framework.authtoken.models import Token
from django.db import transaction
import logging

logger = logging.getLogger(__name__)

class VisitorRegistrationView(APIView):
    permission_classes = [AllowAny]

    def post(self, request):
        try:
            logger.info("Iniciando processo de registro de novo visitante")
            serializer = VisitorRegistrationSerializer(data=request.data)
            
            if serializer.is_valid():
                logger.info("Dados de registro validados com sucesso")
                user = serializer.save()
                logger.info(f"Novo visitante registrado com sucesso: {user.email}")
                
                return Response({
                    'message': 'Registro realizado com sucesso!'
                }, status=status.HTTP_201_CREATED)
            
            logger.error(f"Erro na validação dos dados de registro: {serializer.errors}")
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
            
        except Exception as e:
            logger.error(f"Erro inesperado durante o registro: {str(e)}", exc_info=True)
            return Response({
                'error': 'Erro interno do servidor durante o registro'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class LoginView(APIView):
    permission_classes = [AllowAny]

    def post(self, request):
        try:
            logger.info("Iniciando processo de login")
            serializer = LoginSerializer(data=request.data)
            
            if serializer.is_valid():
                email = serializer.validated_data['email']
                password = serializer.validated_data['password']
                
                logger.info(f"Tentativa de login para o email: {email}")
                
                try:
                    # Primeiro, verificamos se o usuário existe
                    try:
                        user = Visitor.objects.get(email=email)
                    except Visitor.DoesNotExist:
                        logger.warning(f"Usuário não encontrado: {email}")
                        return Response({
                            'error': 'Usuário não encontrado'
                        }, status=status.HTTP_401_UNAUTHORIZED)

                    # Depois autenticamos
                    if not user.check_password(password):
                        logger.warning(f"Senha incorreta para usuário: {email}")
                        return Response({
                            'error': 'Senha incorreta'
                        }, status=status.HTTP_401_UNAUTHORIZED)

                    # Se chegou aqui, o usuário está autenticado
                    logger.info(f"Usuário autenticado com sucesso: {email}")

                    # Gerenciamos o token em uma transação
                    with transaction.atomic():
                        # Primeiro removemos qualquer token existente
                        Token.objects.filter(user=user).delete()
                        
                        # Criamos um novo token
                        token = Token.objects.create(user=user)
                        
                        logger.info(f"Token criado com sucesso para: {email}")
                        
                        return Response({
                            'token': token.key,
                            'user': {
                                'id': user.id,
                                'email': user.email,
                                'name': user.name,
                                'is_superuser': user.is_superuser  # Adicionado o campo is_superuser
                            }
                        })

                except Exception as e:
                    logger.error(f"Erro durante autenticação: {str(e)}", exc_info=True)
                    return Response({
                        'error': 'Erro durante autenticação'
                    }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
            
            logger.error(f"Dados de login inválidos: {serializer.errors}")
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
            
        except Exception as e:
            logger.error(f"Erro inesperado: {str(e)}", exc_info=True)
            return Response({
                'error': 'Erro interno do servidor'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

================================================================================
Arquivo: ./backend/visitors/serializers.py
================================================================================

# visitors/serializers.py
from rest_framework import serializers
from .models import Visitor

class VisitorRegistrationSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True)
    password_confirm = serializers.CharField(write_only=True)

    class Meta:
        model = Visitor
        fields = ['email', 'name', 'password', 'password_confirm']
        extra_kwargs = {
            'email': {'required': True},
            'name': {'required': True}
        }

    def validate_email(self, value):
        if Visitor.objects.filter(email=value).exists():
            raise serializers.ValidationError("Este email já está em uso.")
        return value

    def validate(self, data):
        if data.get('password') != data.get('password_confirm'):
            raise serializers.ValidationError({
                "password_confirm": "As senhas não coincidem"
            })
        return data

    def create(self, validated_data):
        # Remove password_confirm from the data
        validated_data.pop('password_confirm', None)
        password = validated_data.pop('password')
        
        # Create user instance
        user = Visitor(
            email=validated_data['email'],
            name=validated_data['name'],
            username=validated_data['email'],  # Using email as username
            is_active=True
        )
        
        # Set password
        user.set_password(password)
        user.save()
        
        return user
        
        
class LoginSerializer(serializers.Serializer):
    email = serializers.EmailField()
    password = serializers.CharField(style={'input_type': 'password'})


================================================================================
Arquivo: ./backend/visitors/urls.py
================================================================================

# urls.py
from django.urls import path
from .views import VisitorRegistrationView, LoginView

urlpatterns = [
    path('register/', VisitorRegistrationView.as_view(), name='register'),
    path('login/', LoginView.as_view(), name='login'),
]

================================================================================
Arquivo: ./backend/visitors/backends.py
================================================================================

# visitors/backends.py
from django.contrib.auth.backends import ModelBackend
from django.db.models import Q
from .models import Visitor

class EmailBackend(ModelBackend):
    def authenticate(self, request, username=None, password=None, **kwargs):
        try:
            # Check if we're using email or username
            email = username
            if not email:
                email = kwargs.get('email')
            
            if email is None:
                return None
                
            user = Visitor.objects.get(email=email)
            if user.check_password(password):
                return user
            return None
        except Visitor.DoesNotExist:
            return None

================================================================================
Arquivo: ./backend/social/admin.py
================================================================================

# social/admin.py
from django.contrib import admin
from django.utils.html import format_html
from django.urls import reverse
from .models import Comment, Like, Share

@admin.register(Comment)
class CommentAdmin(admin.ModelAdmin):
    list_display = ('author_info', 'chronicle_link', 'content_preview', 'is_approved', 'created_at')
    list_filter = ('is_approved', 'created_at')
    search_fields = ('content', 'author__name', 'author__email', 'chronicle__title')
    actions = ['approve_comments', 'unapprove_comments']
    readonly_fields = ('created_at', 'updated_at')
    ordering = ('-created_at',)
    list_per_page = 20
    
    def content_preview(self, obj):
        """Retorna uma prévia do conteúdo do comentário"""
        return obj.content[:100] + '...' if len(obj.content) > 100 else obj.content
    content_preview.short_description = 'Conteúdo'
    
    def author_info(self, obj):
        """Retorna informações formatadas do autor"""
        return format_html(
            '<div><strong>{}</strong><br><small>{}</small></div>',
            obj.author.name,
            obj.author.email
        )
    author_info.short_description = 'Autor'
    
    def chronicle_link(self, obj):
        """Retorna um link para a crônica relacionada"""
        if obj.chronicle:
            url = reverse('admin:chronicles_chronicle_change', args=[obj.chronicle.id])
            return format_html('<a href="{}">{}</a>', url, obj.chronicle.title)
        elif obj.featured_chronicle:
            url = reverse('admin:chronicles_featuredchronicle_change', args=[obj.featured_chronicle.id])
            return format_html('<a href="{}">{}</a>', url, obj.featured_chronicle.title)
        return "N/A"
    chronicle_link.short_description = 'Crônica'
    
    def approve_comments(self, request, queryset):
        """Ação para aprovar comentários em massa"""
        updated = queryset.update(is_approved=True)
        self.message_user(request, f'{updated} comentário(s) aprovado(s) com sucesso.')
    approve_comments.short_description = 'Aprovar comentários selecionados'
    
    def unapprove_comments(self, request, queryset):
        """Ação para desaprovar comentários em massa"""
        updated = queryset.update(is_approved=False)
        self.message_user(request, f'{updated} comentário(s) desaprovado(s) com sucesso.')
    unapprove_comments.short_description = 'Desaprovar comentários selecionados'
    
    fieldsets = (
        ('Informações do Comentário', {
            'fields': ('content', 'is_approved')
        }),
        ('Relacionamentos', {
            'fields': ('author', 'chronicle', 'featured_chronicle')
        }),
        ('Timestamps', {
            'fields': ('created_at', 'updated_at'),
            'classes': ('collapse',)
        })
    )

@admin.register(Like)
class LikeAdmin(admin.ModelAdmin):
    list_display = ('user_info', 'chronicle_info', 'created_at')
    list_filter = ('created_at',)
    search_fields = ('user__name', 'user__email', 'chronicle__title', 'featured_chronicle__title')
    readonly_fields = ('created_at',)
    ordering = ('-created_at',)
    list_per_page = 20
    
    def user_info(self, obj):
        """Retorna informações formatadas do usuário"""
        return format_html(
            '<div><strong>{}</strong><br><small>{}</small></div>',
            obj.user.name,
            obj.user.email
        )
    user_info.short_description = 'Usuário'
    
    def chronicle_info(self, obj):
        """Retorna informações da crônica"""
        if obj.chronicle:
            url = reverse('admin:chronicles_chronicle_change', args=[obj.chronicle.id])
            return format_html('<a href="{}">{}</a>', url, obj.chronicle.title)
        elif obj.featured_chronicle:
            url = reverse('admin:chronicles_featuredchronicle_change', args=[obj.featured_chronicle.id])
            return format_html('<a href="{}">{}</a>', url, obj.featured_chronicle.title)
        return "N/A"
    chronicle_info.short_description = 'Crônica'
    
    fieldsets = (
        ('Relacionamentos', {
            'fields': ('user', 'chronicle', 'featured_chronicle')
        }),
        ('Timestamp', {
            'fields': ('created_at',),
            'classes': ('collapse',)
        })
    )

@admin.register(Share)
class ShareAdmin(admin.ModelAdmin):
    list_display = ('user_info', 'platform', 'chronicle_info', 'created_at')
    list_filter = ('platform', 'created_at')
    search_fields = ('user__name', 'user__email', 'chronicle__title', 'featured_chronicle__title')
    readonly_fields = ('created_at',)
    ordering = ('-created_at',)
    list_per_page = 20
    
    def user_info(self, obj):
        """Retorna informações formatadas do usuário"""
        return format_html(
            '<div><strong>{}</strong><br><small>{}</small></div>',
            obj.user.name,
            obj.user.email
        )
    user_info.short_description = 'Usuário'
    
    def chronicle_info(self, obj):
        """Retorna informações da crônica"""
        if obj.chronicle:
            url = reverse('admin:chronicles_chronicle_change', args=[obj.chronicle.id])
            return format_html('<a href="{}">{}</a>', url, obj.chronicle.title)
        elif obj.featured_chronicle:
            url = reverse('admin:chronicles_featuredchronicle_change', args=[obj.featured_chronicle.id])
            return format_html('<a href="{}">{}</a>', url, obj.featured_chronicle.title)
        return "N/A"
    chronicle_info.short_description = 'Crônica'
    
    fieldsets = (
        ('Informações do Compartilhamento', {
            'fields': ('platform',)
        }),
        ('Relacionamentos', {
            'fields': ('user', 'chronicle', 'featured_chronicle')
        }),
        ('Informações do Sistema', {
            'fields': ('created_at',),
            'classes': ('collapse',)
        })
    )

================================================================================
Arquivo: ./backend/social/apps.py
================================================================================

from django.apps import AppConfig

class SocialConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'social'


================================================================================
Arquivo: ./backend/social/models.py
================================================================================

# social/models.py
from django.db import models
from django.conf import settings
from chronicles.models import Chronicle
from django.urls import reverse

class Comment(models.Model):
    chronicle = models.ForeignKey(
        Chronicle, 
        on_delete=models.CASCADE, null=True,blank=True,
        related_name='comments'
    )
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='comments'
    )
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_approved = models.BooleanField(default=True)
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = "Comentário"
        verbose_name_plural = "Comentários"

    def __str__(self):
        return f"Comentário por {self.author.name} em {self.chronicle.title}"


class Like(models.Model):
    chronicle = models.ForeignKey(
        Chronicle,
        on_delete=models.CASCADE,
        related_name='likes'
    )
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='likes'
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = [('user', 'chronicle')]
        verbose_name = "Curtida"
        verbose_name_plural = "Curtidas"

    def __str__(self):
        return f"Curtida por {self.user.name} em {self.chronicle.title}"

class Share(models.Model):
    PLATFORMS = (
        ('facebook', 'Facebook'),
        ('twitter', 'Twitter'),
        ('whatsapp', 'WhatsApp'),
        ('telegram', 'Telegram'),
    )
    
    chronicle = models.ForeignKey(
        Chronicle,
        on_delete=models.CASCADE,
        related_name='shares'
    )
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='shares'
    )
    platform = models.CharField(max_length=20, choices=PLATFORMS)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name = "Compartilhamento"
        verbose_name_plural = "Compartilhamentos"

    def __str__(self):
        return f"Compartilhamento {self.platform} por {self.user.name}"

================================================================================
Arquivo: ./backend/social/tests.py
================================================================================

from django.test import TestCase

# Create your tests here.


================================================================================
Arquivo: ./backend/social/views.py
================================================================================

import logging
from rest_framework import viewsets, status, permissions
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError
from .serializers import CommentSerializer, LikeSerializer, ShareSerializer
from .models import Comment, Like, Share

logger = logging.getLogger(__name__)

class BaseChronicleViewSet(viewsets.ModelViewSet):
    """
    Classe base para views relacionadas a crônicas. 
    Inclui métodos utilitários para reutilização.
    """
    def get_queryset(self):
        queryset = self.queryset
        chronicle_id = self.request.query_params.get('chronicle')
        user_id = self.request.query_params.get('user')
        
        if chronicle_id:
            queryset = queryset.filter(chronicle_id=chronicle_id)
        if user_id:
            queryset = queryset.filter(user_id=user_id)
        
        return queryset

class CommentViewSet(BaseChronicleViewSet):
    queryset = Comment.objects.all()
    serializer_class = CommentSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    
    def create(self, request, *args, **kwargs):
        logger.info("Iniciando criação de comentário...")
        
        serializer = self.get_serializer(data=request.data)
        try:
            serializer.is_valid(raise_exception=True)
            self.perform_create(serializer)
            headers = self.get_success_headers(serializer.data)
            logger.info("Comentário criado com sucesso.")
            return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)
        except ValidationError as e:
            logger.warning(f"Erro de validação: {e}")
            return Response({'detail': e.detail}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Erro ao criar comentário: {e}")
            return Response({'detail': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def perform_create(self, serializer):
        logger.debug(f"Salvando comentário: {serializer.validated_data}")
        serializer.save(author=self.request.user)

class LikeViewSet(BaseChronicleViewSet):
    queryset = Like.objects.all()
    serializer_class = LikeSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def create(self, request, *args, **kwargs):
        chronicle_id = request.data.get('chronicle')
        if not chronicle_id:
            return Response({'detail': 'ID da crônica é obrigatório'}, status=status.HTTP_400_BAD_REQUEST)
        
        if Like.objects.filter(user=request.user, chronicle_id=chronicle_id).exists():
            return Response({'detail': 'Você já curtiu esta crônica'}, status=status.HTTP_400_BAD_REQUEST)
        
        serializer = self.get_serializer(data=request.data)
        try:
            serializer.is_valid(raise_exception=True)
            self.perform_create(serializer)
            headers = self.get_success_headers(serializer.data)
            logger.info("Curtida adicionada com sucesso.")
            return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)
        except ValidationError as e:
            logger.warning(f"Erro de validação ao curtir: {e}")
            return Response({'detail': e.detail}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Erro ao curtir crônica: {e}")
            return Response({'detail': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def perform_create(self, serializer):
        logger.debug("Adicionando curtida...")
        serializer.save(user=self.request.user)

class ShareViewSet(BaseChronicleViewSet):
    queryset = Share.objects.all()
    serializer_class = ShareSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def create(self, request, *args, **kwargs):
        logger.info("Iniciando compartilhamento de crônica...")
        
        serializer = self.get_serializer(data=request.data)
        try:
            serializer.is_valid(raise_exception=True)
            self.perform_create(serializer)
            headers = self.get_success_headers(serializer.data)
            logger.info("Compartilhamento realizado com sucesso.")
            return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)
        except ValidationError as e:
            logger.warning(f"Erro de validação ao compartilhar: {e}")
            return Response({'detail': e.detail}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Erro ao compartilhar crônica: {e}")
            return Response({'detail': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def perform_create(self, serializer):
        logger.debug("Salvando compartilhamento...")
        serializer.save(user=self.request.user)


================================================================================
Arquivo: ./backend/social/serializers.py
================================================================================

# serializers.py
import logging
from rest_framework import serializers
from .models import Comment, Like, Share
from django.urls import reverse
from chronicles.models import Chronicle

logger = logging.getLogger(__name__)

class CommentSerializer(serializers.ModelSerializer):
    author_name = serializers.SerializerMethodField()
    chronicle = serializers.PrimaryKeyRelatedField(
        queryset=Chronicle.objects.all(), 
        required=True
    )
    
    class Meta:
        model = Comment
        fields = ['id', 'content', 'author', 'author_name', 'created_at', 
                 'updated_at', 'is_approved', 'chronicle']
        read_only_fields = ['author', 'is_approved', 'created_at', 'updated_at']
        
    def get_author_name(self, obj):
        return obj.author.name if hasattr(obj, 'author') else self.context['request'].user.name

    def validate(self, data):
        logger.debug(f"Validating comment data: {data}")
        
        if 'chronicle' not in data:
            raise serializers.ValidationError("Chronicle field is required")
            
        return data

class LikeSerializer(serializers.ModelSerializer):
    class Meta:
        model = Like
        fields = ['id', 'user', 'chronicle', 'created_at']
        read_only_fields = ['user', 'created_at']

class ShareSerializer(serializers.ModelSerializer):
    share_url = serializers.SerializerMethodField()
    
    class Meta:
        model = Share
        fields = ['id', 'user', 'platform', 'chronicle', 'created_at', 'share_url']
        read_only_fields = ['user', 'created_at', 'share_url']
        
    def get_share_url(self, obj):
        if isinstance(obj, dict):
            chronicle_id = obj.get('chronicle')
        else:
            chronicle_id = obj.chronicle.id
            
        base_url = self.context['request'].build_absolute_uri('/')
        chronicle_url = reverse('chronicle-detail', args=[chronicle_id])
        full_url = base_url.rstrip('/') + chronicle_url
        
        platform = obj.get('platform') if isinstance(obj, dict) else obj.platform
        
        share_urls = {
            'facebook': f"https://www.facebook.com/sharer/sharer.php?u={full_url}",
            'twitter': f"https://twitter.com/intent/tweet?url={full_url}",
            'whatsapp': f"https://api.whatsapp.com/send?text={full_url}",
            'telegram': f"https://t.me/share/url?url={full_url}"
        }
        
        return share_urls.get(platform, full_url)

================================================================================
Arquivo: ./backend/social/urls.py
================================================================================

# urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import CommentViewSet, LikeViewSet, ShareViewSet

router = DefaultRouter()
router.register(r'comments', CommentViewSet)
router.register(r'likes', LikeViewSet)
router.register(r'shares', ShareViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

